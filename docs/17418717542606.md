# HTTP个版本及队首阻塞解决方案对比
HTTP（超文本传输协议）的发展经历了HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0的发展，各版本的特点以及队首阻塞问题的解决方案如下。

## **HTTP1.0**
* **特点**
    * **短连接：** 每个请求都需要建立新的连接，请求完成后断开连接。
    * **无状态：** 每个请求都是独立的，服务器不会记录之前的请求信息。

* **队首阻塞问题**
    * 由于每个请求都需要建立连接，频繁的建立连接和关闭会导致性能瓶颈，由其在高延迟的网络环境下。

## **HTTP1.1**
* **特点**
    * **长连接：** 引入了持久连接（Persistent Connection），允许在同一个TCP连接下发送多个请求和响应。
    * **管道化（Pipelining）：** 允许在同一个连接下发送多个请求，客户端不需要等待前一个请求的响应。然而服务端必须按照请求的顺序返回响应。
    * **缓存控制：** 引入了更多的缓存控制机制，如`Cache-control`头部。

* **队首阻塞问题**
    * 虽然HTTP1.1引入了管道化，服务端的返回是按照请求的顺序进行的，如果一个请求的响应延迟，那么后续的请求就会被阻塞。

## **HTTP2.0**
* **特点** 
    * **二进制协议** HTTP2.0使用了二进制格式而不是文本格式，提高解析效率。
    * **多路复用** 允许在同一个连接下同时发送多个请求和响应。解决了HTTP1.0的队首阻塞问题。
    * **头部压缩** 使用HPACK算法对HTTP头部进行压缩，减少头部开销。
    * **服务器推送** 服务器可以主动向客户端推送资源，而不需要客户端明确请求。

* **队首阻塞问题**
    * HTTP2.0通过多路复用解决了应用层的队首阻塞问题，但在传输层仍然存在队首阻塞问题。如果出现TCP丢包，由于TCP的失败重传机制，之后的包要等待重传成功才会到达客户端。

## **HTTP3.0**
* **特点**
    * **基于QUIC协议** HTTP3.0不再使用TCP，而是基于Google开发的QUIC协议，QUIC协议是运行在UDP之上的。
    * **多路复用** 与HTTP2.0类似，HTTP3.0也支持多路复用，但是由于QUIC的特性，每个流（stream）是独立的，不再受TCP队首阻塞的影响。
    * **快速握手** QUIC协议支持0-RTT和1-RTT握手，减少了连接建立的延迟。
    * **内置加密** QUIC协议内置了TSL1.3，提供了更好的安全性。
    
* **队首阻塞问题** 
    * HTTP3.0基于QUIC协议彻底解除了传输层的队首阻塞问题。由于QUIC的每个流是独立的，即使某个流的数据报丢失，也不会影响其他数据报的传输。

-------

**0-RTT和1-RTT的解释**
* **1-RTT** 是QUIC的标准握手模式，适用于首次连接或者无法复用之前的连接
* **0-RTT** 是QUIC的优化模式，复用旧的会话信息。

**幂等请求**
* 无论一个请求执行多少次，其结果都是相同的。比如`GET` /user/123，无论请求多少次，返回的结果都是相同的。
**非幂等请求**
* `POST` `/order` 每次请求都会创建一个新的订单。

**重放攻击（Replay Attack）**
`重放攻击`指的是请求被攻击者拦击，并重复发送合法请求，造成重复执行的风险。      
* 如何预防
    * 使用HTTPS或者QUIC协议。
    * 使用一次性token，确保同一个请求不会被重复使用。
    * 时间戳机制，只接受一定时间范围内的请求，过期请求无效。
    * 仅允许幂等请求使用0-RTT，如`GET`、`DELETE`、`PUT`，而`POST`需要1-RTT确保安全性。

**TSL1.3握手的过程**
* 0-RTT：
    * 客户端发送`ClientHello`，包含早期的秘钥信息（PSK，Pre-Shared Key）和早期数据（Early Data），如`GET`请求。
    * 服务端返回`ServerHello`
        * 服务端如果接受0-RTT数据，立即解密处理
        * 如果服务器不接受0-RTT，则丢弃早期数据，回退到1-RTT模式。
    * 容易被重放攻击，只能用于幂等请求。
    * 总RTT
        * 0-RTT 直接开始传输数据。

* 1-RTT：
    * 客户端发送`ClientHello`
        * 包含支持的加密算法、TSL版本（1.3）、随机数（ClientRandom）
        * 新增`Key Share`（秘钥共享）字段，用于提前发送密钥，减少RTT
    * 服务端响应`ServerHello`
        * 选择加密算法，并返回`ServerRandom`（服务器随机数）
        * 同步返回`key Share`，完成密钥交换。
        * 同步返回`Certificate`（证书），用于身份验证 
    * 客户端验证服务器证书
        * 计算最终会话密钥`Shared Secret`，完成对称加密密钥生成。
    * 双发发送`Finished`
        * 服务端发送`Finished`，表示握手完成。
        * 客户端收到后，发送`Finished`，次数握手完成，开始加密通信
    * 总RTT：
        * `ClientHello` -> `ServerHello`+证书 -> 1-RTT完成

* 总结：
    * 1-RTT（首次），0-rtt（会话恢复）    