# 网络优化
业界定义的网络请求延迟300ms之内属于比较优秀，一般不要超过500ms。   
请求成功率要达到99%属于优秀，能达到99.9%属于非常优秀。     
我们项目的网络延迟平均值在274ms，成功率98.3%，还有一定的优化空间。      
优化后，延迟201ms，降低了26%；请求成功率99%，提升了0.7%。        

一次网络请求会经历如下过程：       
DNS解析 -> 建立连接 -> 协议传输 -> 后台或cdn逻辑 -> 数据返回 -> 结束连接

## DNS优化
我们使用了HTTPDNS代替了默认的Localdns进行域名的解析，HTTPDNS 是一种基于 HTTP 协议进行域名解析的方式，相对于传统的基于 UDP 协议的 DNS（即 LocalDNS），它通过 HTTP 请求直接向权威 DNS 服务器或运营商提供的解析服务获取解析结果。    
HTTPDNS和Localdns对比如下：
* 解析方式
    * HTTPDNS使用http（s）协议直接从HTTPDNS服务器请求
    * LOCALDNS使用UDP协议解析，可能会递归查询，受本地缓存影响
        * 先检查本地缓存
        * 若没有，则去hosts文件查询ip
        * 若没有，查询本地DNS服务器
        * 若没有，递归解析（LOCALDNS -> 根DNS -> 顶级域（TLD）DNS -> 权威DNS）
            * **查询根 DNS 服务器（Root DNS）**
                * LocalDNS 先向 根 DNS 服务器（全球 13 组 Root Server）发送查询请求。
                * 根 DNS 不会直接返回 example.com 的 IP，而是返回 .com 顶级域名服务器（TLD DNS） 的地址。
            * **查询顶级域名服务器（TLD DNS）**
                * LocalDNS 向 .com 顶级域名服务器（TLD DNS）查询 example.com 的解析地址。
                * TLD 服务器返回 example.com 的 权威 DNS 服务器地址。
            * **查询权威 DNS 服务器**
                * LocalDNS 直接向 example.com 的 权威 DNS 服务器 发送查询请求。
                * 权威 DNS 服务器返回最终的 IP 地址（如 93.184.216.34）。
    
* 解析耗时
    * HTTPDNS解析大概10ms ~ 100ms
    * LOCALDNS解析大概20ms ~ 200ms

* 缓存优化
    * HTTPDNS可以本地自定义缓存策略
    * LOCALDNS受ISP（互联网提供商）缓存影响

* 劫持/污染
    * HTTPDNS直接先权威服务器请求，避免劫持和污染
    * LOCALDNS可能会被劫持

### 使用方式
1. 从HTTPDNS服务器请求域名对应的ip。
2. 用解析后的域名ip替换域名，重新构造请求。
3. 在请求头中添加Host字段，确保服务器能识别请求的目标域名。
4. 使用afnetworking进行网络请求。

### 缓存策略及更新策略
服务器返回域名对应的ip的同时会携带ip的TTL，在本地使用NSUserdefault缓存域名对应的ip和TTL，避免重复解析，当ip失效后，会再次从HTTPDNS服务器请求新的ip。但是会遇到一个新的问题，我们的移动网络是极其不稳定的，我们的手机在某个时间可能连接着WiFi，再下一个时间段有连接移动网络，移动网络也可能从5G切换到4G。每次网络的切换对应背后整个网络链路都不一样，这意味着同一个ip并不一直是最优的ip。具体有以下三种方式更新：
1. 定期监听HTTPDNS返回的TTL，当发现ip即将失效，发起请求下一轮ip列表更新缓存。
2. 监听网络状态的切换，比如从WiFi切换到5g或4g，及时出发ip列表刷新。
3. 配置中心下发，如果服务器想分流来缓解某个服务器的压力，可以通过下发新的ip给客户端使用
4. 另外ip对应的缓存key可以使用携带不同网络标识比如WiFi、5g、4g等。

### 回滚方案
如果HTTPDNS解析失败，应用自动回退到LOCALDNS解析，以提供高可靠性。

### DNS解析收益
从线上数据看DNS解析从18ms减少到了8ms，整体减少了10ms。

## TCP连接优化
我们使用的http协议是基于底层TCP协议之上的，TCP是面向连接、可靠的传输协议，每次客户端和服务端进行TCP连接时，都会经历三次握手，连接成功后才能进行数据交换。 
我们再从头看一下一次网络请求要经历的过程DNS解析 -> TCP连接 -> TSL连接 -> 数据交换，
1. DNS解析要从DNS服务器获取id，要经过一次RTT（往返时间）。
2. TCP建连和也需要经过1次RTT。
3. TSL连接需要进行证书校验和密钥交换所以要经过2次RTT。

所以综上所述在数据交换前要经过4次RTT，能有效的减少RTT的次数即可减少连接时间。在优化连接的过程中怎么做到减少RTT的次数呢？我们使用了`Cronet`网络库。  

### Cronet的优势 
1. HTTP/2和QUIC的支持：Cronet支持HTTP2和QUIC，这两者都可以提高网络请求的吞吐量并减少延迟，在高并发、频繁请求的场景中，比传统的HTTP/1.x更为高效。
2. 预连接：`Cronet`通过`CronetEngine`创建请求完成后在发送请求前在后台会自动进行连接预热，并且他能够缓存连接，从而减少TSL和TCP的握手次数。
3. 智能重试机制：`Cronet`会对网络失败的请求自动进行重试，从而提升网络请求的成功率。

在后续的不断优化过程，我们与后台协商支持了`QUIC`协议(Quick UDP Internet Connections)，是一种全新的基于`UDP`的web开发协议，有google开发提供。可以用一个公式表示：
```
QUIC = TCP + TSL + HTTP2
```
### QUIC协议
`QUIC`是基于UDP的一种协议，但是它具有TCP的可靠性、拥塞控制、流量控制等优点，且在TCP之上做了一些优化比如避免了队首阻塞。QUIC还具有TSL的安全特性，避免了TSL建连时的握手耗时，从而减少了RTT来建立安全回话。`QUCI`的一个目的是为了整合TCP协议的可靠性和UDP协议的速度和效率。

`队首阻塞`：使用TCP在进行数据包传输过程中，比如传输了3个包，其中第二个包发生了丢包，由于TCP的失败重传机制，失败的包会进行重传，此时第三个包会阻塞，等待第二个包传输成功。但是使用`QUIC`三个报的传输时独立互不影响的，某一个包的失败重传不会影响其他包的传输。

`QUIC`不仅加速握手过程，而且支持0-RTT的握手方式，及在第一次握手过程中客户端就可以发送加密数据，不必等待完整的握手过程完成

### HTTP2与QUIC竞速
1. **首次请求**
    1. 首次请求，客户端使用正常的HTTP协议，此过程与正常的HTTP请求唯一区别是，携带了支持QUIC协议的信息，告诉server端，Client支持QUIC请求。
    2. Server收到请求后，判断自身是否支持QUIC协议
    3. 如果Server支持QUIC协议，Server直接在`response header`中添加一个响应头`alt-syc`,`alt-syc`携带的信息主要包括以下三部分：
        1. `quic=ip:port` 告诉客户端QUIC建连的IP和端口
        2. `ma=xxxx` 主要用来表示服务是否可用（是否在有效期）
        3. `v=xxx` 表示Server支持的QUIC版本
    4. 如果Server不支持`QUIC`协议，则直接按照HTTP协议返回，即`response header`中不包含`:alt-syc`头部信息。
2. **第二次请求**
    1. 客户端第二次请求，`Cronet`网络库同时发出基于`TCP`的HTTP连接和基于`UDP`的`QUIC`连接。
        1. `TCP`连接基于正常的`DNS`解析进行连接
        2. `QUIC`连接基于第一次请求`Server`端在`alt-syc`头信息中标注的`ip:port`进行连接
    2. Server接收两种连接后均会作出反馈给客户端。
    3. 客户端等待两个连接的响应，`Cronet`会按照时间维度去判断哪个连接首先建立成功。
        1. 如果`QUIC`连接首先完成，则后续的请求均走此`QUIC`连接。
        2. 如果`TCP`连接首先完成，则后续直接按照`TCP`连接与Server通信。
3. **总结**    
看完这两个过程，可以发现，`Cronet`创建`QUIC`连接时，其实是不依赖于`DNS`解析，而是由`Server`提前告知的`ip:port`建立连接的，因此，`Cronet`对`HTTP`和`QUIC`协议的选择可以归纳为以下几点：
    * 首次请求，基于DNS建立`TCP`连接，如果Server端支持`QUIC`协议，则下发`QUIC`建连的信息。
    * 第二次请求，采用竞速模式，以时间维度择其优。
    * `QUIC`建连时，不依赖本地`DNS`解析，而是按照Server下发的信息建连。

### QUIC连接迁移
`QUIC连接迁移`允许网络连接在客户端IP地址或者网络接口发生变化时保持不间断。   
1. **`QUIC`连接迁移是指在以下情况下保持连接不断开**：
    * 设备切换网络（如WiFi切4G/5G）
    * IP地址变化（如DHCP租约更新）
    * 多路径切换（如同时使用有限线+无线）
2. **工作原理**
    1. 连接标识机制
        1. **连接ID（connection ID）**：`QUIC`使用独立的连接标识而非传统的`ip+端口`四元组。
        2. **非IP绑定**：连接不需要IP/端口，只要客户端能提供有效的连接ID。
3. **迁移过程**
    * **网络变化检测**：客户端感知到ip地址变化
    * **新路径探测**：通过新路径发送包含原连接ID的数据包
    * **服务端验证**：服务器检查连接Id的有效性。
    * **无缝切换**：保持所有流（stream）状态不变
4. **技术优势**
    * **零停机切换**：
        * 视频会议下不会中断
        * 文件下载持续进行
        * 游戏连接不会掉线
    * **多路径支持**：
        * 可以同时利用WiFi和蜂窝网络
        * 自动选择最佳路径

### HTTPS SSL session持久化和SSL复用
`HTTPS SSL session持久化和SSL复用`是减少网络延迟和提高性能的重要技术，每次与服务器建立新的HTTPS连接时，都需要进行SSL/TSL握手，都会消耗大量时间，尤其是在网络较差场景中。TSL1.2需要2-RTT，TSL1.3需要1-RTT。
1. **SSL会话复用**
SSL/TSL握手过程中会进行身份认证、加密算法协商、密钥交换等步骤，`Cronet`利用了**会话复用**来避免每次请求都进行的完整握手。
    * **SSL会话缓存：** 当第一次建立连接并进行SSL/TLS握手时，服务器和客户端会协商出一个 SSL会话，并将会话信息（如会话密钥、证书链等）缓存到客户端和服务器中。以后每次发起请求时，客户端可以直接使用之前的 会话ID 或 会话票据（Session Ticket）来复用会话信息，从而避免重新进行全套的握手过程。
    * **SSL会话复用** 可以减少握手的时间，避免了重新交换公钥、私钥和加密参数，只需要基于会话ID恢复握手状态。

### HTTP/2协议
* **HTTP/2：** HTTP/2协议基于**多路复用**技术，可以在一个连接上同时处理多个请求和响应，减少了建立连接的开销。HTTP/2还利用了**单一连接复用**和**TLS连接复用**，从而减少了需要多次握手的情况。
* **二进制协议：** HTTP/2使用了二进制格式而不是文本格式，提高了解析效率。
* **头部压缩：** 
    * **HPACK压缩：** HTTP/2使用HPACK算法压缩头部信息，减少了头部的大小。
    * **静态表和动态表：** HPACK使用了静态表和动态表来存储和引用头部字段，进一步减少重复传输。
* **服务器推送** 服务器可以向客户端主动推送资源，减少延迟
* **流优先级** HTTP/2允许为流设置优先级，确保重要资源优先传输。
* **流依赖** 流可以依赖其他流，确保依赖资源按顺序传输。
* **流量控制**
    * **窗口控制：** HTTP/2使用流量控制机制，防止发送方压倒接收方。
    * **动态调整：** 流量空口可以动态调整，适应网络状况。

## **Cronet为什么在弱网下性能更优**
`Cronet`主要在**协议优化**、**连接管理**、**数据传输效率**方面做了优化
1. **多协议支持（HTTP/2和QUIC）**
这些协议针对网络延迟、带宽有限的情况下进行了深度优化。
    * 多路复用
    * 头部压缩
* QUIC：
    * **基于UDP** 他能更快的建立连接，并通过0-RTT（零轮次）减少握手延迟。
    * **多路复用与无队头阻塞** QUIC 允许多个请求并行传输，且不同请求的传输不会相互阻塞，从而有效应对高延迟和低带宽的情况。
2. **连接复用和智能连接管理**
连接复用 是 Cronet 提供的一个重要特性，它允许多个请求复用同一个连接，从而避免频繁建立新的连接和进行重复的 SSL/TLS 握手过程。
3. **网络重试和错误容忍**
    * 当请求在网络环境不佳时失败时，Cronet 会自动进行重试，尤其是在出现连接超时、丢包或者断网等情况时。重试机制不仅减少了因为一次请求失败导致的用户体验问题，还可以根据网络状态自动调整重试策略（如延时重试）。 
4. **数据压缩和传输优化**
    * **数据压缩：** Cronet 支持通过 GZIP 或其他压缩算法来压缩请求和响应的正文内容。对于文本数据、JSON、HTML 等格式的响应，这可以显著减少传输的数据量，尤其在带宽受限的情况下提高传输效率。
    * **请求合并：** Cronet 还会智能地将多个小请求合并为一个大请求，减少因多次请求带来的延迟和开销。例如，在弱网环境中，Cronet 会尝试合并多个小文件请求，减少往返请求次数。 
## 项目优化
理论上只要注入`Cronet`，所有基于`NSURLConnection`和`NSURLSession`的网络请求都会被`Crone`拦截和处理，在我们的项目中没有直接使用 URLSession ，而是使用了 AFNetworking，它可被看成是 URLSession 的包装，也就是其内部依然使用 URLSession。这样一来，我们只需要修改生成 AFURLSessionManager 的地方，传入特殊的 URLSessionConfiguration 即可，而 AFURLSessionManager 内部会生成对应的 URLSession。这样，其它使用 AFURLSessionManager 的地方也就无需修改，我们在启动配置`Cronet`后，调用`registerHttpProtocolHandler`，及完成注入，这样包括`WKWebview`的请求也会被`Cronet`拦截处理，同样用到了`Cronet`的底层优化能力。

## TCP/TSL优化收益
从线上数据看TCP连接从74ms减少到了11ms，减少了63ms

## 接口改造
1. 接口合并，与服务端配合，把多个相关联的小接口合并成一个大的接口，减少了请求的次数。
2. 服务端返回字段整理，与服务端沟通，优化返回字段，只返回客户端需要的字段。
3. 本地缓存，针对`GET`请求，使用`URLCache`配合`Cache-Control`，减少请求次数。
    1. 客户端设置请求的`cachePolicy`为`useProtocolCachePolicy`遵循服务器的`Cache-Control`规则
    2. 设置`reloadIgnoringLocalCacheData`忽略本地缓存强制从服务器拉去新的数据。
    3. 设置`returnCacheDataElseLoad`优先使用本地缓存，本地缓存没有从服务器拉取。
4. 并发控制，合理设置最大并发数，避免请求过多占满宽带影响体验。

## 优化收益
连接优化的收益主要体现在网络延迟和成功率上，结合在`搜狐资讯`商家端订单列表请求来看，网络延时降低了26%，请求成功率提升了0.7%，整体收益明显。

## 参考文章
[iOS 网络优化和网络基础](https://juejin.cn/post/6868945803856052231) 
[百度APP网络深度优化实践（网络连接优化篇）](http://www.52im.net/thread-2479-1-1.html)  
[QUIC协议初探-iOS实践](https://cloud.tencent.com/developer/article/1071825)   
[Cronet网络库系列(一)：用例与原理实现详解](https://zhuanlan.zhihu.com/p/93362473)   
[iOS 集成 Cronet 的可能方案](https://github.com/yuhanle/blogbag/issues/17) 
[Cronet网络协议选择之HTTP2与QUIC的竞速](https://glanwang.com/2021/03/24/Android/Cronet%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E9%80%89%E6%8B%A9%E4%B9%8BHTTP2%E4%B8%8EQUIC%E7%9A%84%E7%AB%9E%E9%80%9F/)